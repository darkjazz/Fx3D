{\rtf1\ansi\ansicpg1252\cocoartf949\cocoasubrtf540
{\fonttbl\f0\fnil\fcharset238 Inconsolata;}
{\colortbl;\red255\green255\blue255;\red191\green0\blue0;\red0\green0\blue0;\red0\green0\blue191;
\red0\green115\blue0;}
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\fs24 \cf2 // zone 0\cf3 \
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural\pardirnatural
\cf3 ~bfreqs = [ 20, 100, 200, 300, 400, 510, 630, 770, 920, 1080, 1270, 1480, 1720,\
	  2000, 2320, 2700, 3150, 3700, 4400, 5300, 6400, 7700, 9500, 12000, 15500, 20000 ];\
\
~cfreqs = \cf4 Array\cf3 .newClear(~bfreqs.size - 1);\
~cbands = \cf4 Array\cf3 .newClear(~bfreqs.size - 1);\
~bfreqs.doAdjacentPairs(\{\cf4 |lo, hi, i|\cf3 \
	~cfreqs.put(i, lo + (hi - lo / 2));\
	~cbands.put(i, hi - lo / 2 );\
\});\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf3 \
\pard\pardeftab720\ql\qnatural
\cf3 ~flt = (\
	\cf5 \\bpf\cf3 : \{\cf4 |src, freqs, rq, amps|\cf3  \cf4 BPF\cf3 .ar(src, freqs, rq, 50) \},\
	\cf5 \\eq\cf3 : \{\cf4 |src, freqs, rq, amps|\cf3  \cf4 MidEQ\cf3 .ar(src, freqs, rq, 20) \},\
	\cf5 \\rhpf\cf3 : \{\cf4 |src, freqs, rq, amps|\cf3  \cf4 RHPF\cf3 .ar(src, freqs, rq, 50) \}\
);\
\
~nzw = (\
	\cf5 \\logistic\cf3 : \{\cf4 |freq, amp|\cf3  \cf4 Logistic\cf3 .ar(3.7, freq, 0.25, amp) * 0.1 \},\
	\cf5 \\dust\cf3 : \{\cf4 |freq, amp|\cf3  \cf4 Dust2\cf3 .ar(freq.linlin(60, 17750, 60, 1755), amp) \},\
	\cf5 \\lfn\cf3 : \{\cf4 |freq, amp|\cf3  \cf4 LFNoise0\cf3 .ar(freq, amp) * 0.1\}\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardeftab720\ql\qnatural\pardirnatural
\cf3 );\
\
\pard\pardeftab720\ql\qnatural
\cf3 ~ndef = \{\cf4 |name, nfunc, ffunc|\cf3 \
	\cf4 SynthDef\cf3 (name, \{\cf4 |out, efx, aamp, eamp, samp, dur, rate, buffer, clip, \
			xang, yang, zang, xpush, ypush, zpush, doneAction = 2|\cf3 \
		\cf4 var\cf3  env, sig, args, pointer, nsrc, filt, noise, azm, elv, rho, clumped, a, b, c, d, w, x, y, z;\
		env = \cf4 Control\cf3 .names([\cf5 \\env\cf3 ]).kr(\cf4 Env\cf3 .newClear(8).asArray);\
		pointer = \cf4 LFSaw\cf3 .kr(rate, 1, 0.5, 0.5);\
		noise = \cf4 AtsNoise\cf3 .kr(buffer, (0..23), pointer);\
		nsrc = \cf4 SynthDef\cf3 .wrap(nfunc, \cf4 nil\cf3 , [~cfreqs, noise]) * samp;\
		filt = \cf4 SynthDef\cf3 .wrap(ffunc, \cf4 nil\cf3 , [nsrc, ~cfreqs, ~cbands / ~cfreqs]);\
		sig = (filt ** 0.5).clip2(clip) \
			* \cf4 EnvGen\cf3 .kr(env, timeScale: dur, doneAction: doneAction);\
		\cf4 Out\cf3 .ar(efx, \cf4 Mix\cf3 (sig) * eamp);\
		clumped = sig.clump(6);\
		#a, b, c, d = \cf4 Array\cf3 .fill(4, \{\cf4 |i|\cf3  \cf4 Mix\cf3 (clumped[i]) \});\
		#w, x, y, z = \cf4 A2B\cf3 .ar(a, b, c, d);\
		#w, x, y, z = \cf4 AtkPush\cf3 .ar(w, x, y, z, xpush, ypush, zpush);\
		\cf4 Out\cf3 .ar(out, \cf4 AtkRotateXYZ\cf3 .ar(w, x, y, z, xang, yang, zang) * aamp);\
	\}).add;\
\};\
~noisedefs = \cf4 Array\cf3 ();\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardeftab720\ql\qnatural\pardirnatural
\cf3 ~nzw.keysValuesDo(\{\cf4 |skey, sfnc|\cf3 \
	~flt.keysValuesDo(\{\cf4 |fkey, ffnc|\cf3 \
		~noisedefs = ~noisedefs.add((fkey ++ skey).asSymbol);\
		~ndef.value((fkey ++ skey).asSymbol, sfnc, ffnc);\
	\})\
\});\
\pard\pardeftab720\ql\qnatural
\cf3 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural\pardirnatural
\cf4 SynthDef\cf3 (\cf5 \\zone0_mono\cf3 , \{\cf4 |out, amp, buf, azm, elv, dur, loop=0, xang, yang, zang, xpush, ypush, zpush, gate=1.0|\cf3 \
	\
	\cf4 var\cf3  sig, w, x, y, z, env;\
	env = \cf4 EnvControl\cf3 .kr;\
	sig = \cf4 PlayBuf\cf3 .ar(1, buf, loop: loop) * \cf4 EnvGen\cf3 .kr(env, gate, timeScale: dur, doneAction: 2);\
	#w, x, y, z = \cf4 AtkMonoToB\cf3 .ar(sig, azm, elv);\
	#w, x, y, z = \cf4 AtkPush\cf3 .ar(w, x, y, z, xpush, ypush, zpush);\
	\cf4 Out\cf3 .ar(out, \cf4 AtkRotateXYZ\cf3 .ar(w, x, y, z, xang, yang, zang) * amp)\
	\
\}).add;\
\pard\pardeftab720\ql\qnatural
\cf3 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural\pardirnatural
\cf4 SynthDef\cf3 (\cf5 \\zone0_stereo\cf3 , \{\cf4 |out, amp, buf, azm, wid, elv, dur, loop=0, xang, yang, zang, xpush, ypush, zpush, gate=1.0|\cf3 \
	\
	\cf4 var\cf3  l, r, w, x, y, z, env;\
	env = \cf4 EnvControl\cf3 .kr;\
	#l, r = \cf4 PlayBuf\cf3 .ar(2, buf, loop: loop) * \cf4 EnvGen\cf3 .kr(env, gate, timeScale: dur, doneAction: 2);\
	#w, x, y, z = \cf4 AtkSterToB\cf3 .ar(l, r, azm, wid, elv);\
	#w, x, y, z = \cf4 AtkPush\cf3 .ar(w, x, y, z, xpush, ypush, zpush);\
	\cf4 Out\cf3 .ar(out, \cf4 AtkRotateXYZ\cf3 .ar(w, x, y, z, xang, yang, zang) * amp)\
	\
\}).add;\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf3 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardeftab720\ql\qnatural\pardirnatural
\cf4 SynthDef\cf3 (\cf5 \\zone0_grain\cf3 , \{\cf4 |out, efx, amp, aamp, gate, dur, buffer, maxdel, tfrq, tdev, gdur, pos, brate, \
		envA, envB, envf, xang, yang, zang|\cf3 \
	\cf4 var\cf3  trig, sig, del, shift, a, b, c, d, env, w, x, y, z;\
	env = \cf4 EnvGen\cf3 .kr(\cf4 EnvControl\cf3 .kr, gate, timeScale: dur, doneAction: 2);\
	del = \cf4 ArrayControl\cf3 .kr(\cf5 \\delays\cf3 , 4, 0);\
	shift = \cf4 ArrayControl\cf3 .kr(\cf5 \\shifts\cf3 , 4, 1);\
	trig = \cf4 DelayN\cf3 .ar(\cf4 Impulse\cf3 .ar(tfrq), 0.1, \cf4 TRand\cf3 .ar(0.0, tdev, \cf4 Impulse\cf3 .ar(tfrq)));\
	sig = \cf4 BufGrainI\cf3 .ar(trig, gdur, buffer, brate, pos, envA, envB, envf, 1) * env;\
	#a, b, c, d = \cf4 Array\cf3 .fill(4, \{\cf4 |i|\cf3 \
		\cf4 PitchShift\cf3 .ar(\cf4 DelayN\cf3 .ar(sig, maxdel, del[i]), shift[i]) * aamp;\
	\});\
	#w, x, y, z = \cf4 A2B\cf3 .ar(a, b, c, d);\
	\cf4 Out\cf3 .ar(out, \cf4 AtkRotateXYZ\cf3 .ar(w, x, y, z, xang, yang, zang) * amp)\
\}).add;\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural
\cf3 \
\cf4 SynthDef\cf3 (\cf5 \\zone0_aformat\cf3 , \{\cf4 |out, efx, buf, amp, eamp, xang, yang, zang|\cf3 \
	\cf4 var\cf3  a, b, c, d, w, x, y, z;\
	#a, b, c, d = \cf4 PlayBuf\cf3 .ar(4, buf, doneAction: 2).distort;\
	#w, x, y, z = \cf4 A2B\cf3 .ar(a, b, c, d) * amp;\
	\cf4 Out\cf3 .ar(efx, w * eamp);\
	\cf4 Out\cf3 .ar(out, \cf4 AtkRotateXYZ\cf3 .ar(w, x, y, z, xang, yang, zang));\
\}).add;\
\pard\pardeftab720\ql\qnatural
\cf3 \
\
\cf2 // zone 1\cf3 \
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural\pardirnatural
\cf4 SynthDef\cf3 (\cf5 \\line\cf3 , \{\cf4 |out, in, gate = 1.0, i_wrp = 0.1, frq, wsz, dns, rnd, amp|\cf3 \
	\cf4 var\cf3  bufs, recs, ptrs, phases, deltimes, output, trigs, input;\
	deltimes = [0, 1 / i_wrp * 0.5, 1 / i_wrp];\
	bufs = \cf4 Array\cf3 .fill(3, \{ \cf4 LocalBuf\cf3 (\cf4 SampleRate\cf3 .ir * 2) \});\
	ptrs = \cf4 Array\cf3 .fill(3, \{\cf4 |i|\cf3  \cf4 LFSaw\cf3 .kr(i_wrp, 0, 0.5, 0.5) \});\
	trigs = \cf4 Array\cf3 .fill(3, \{\cf4 |i|\cf3  \cf4 DelayN\cf3 .kr(\cf4 Impulse\cf3 .kr(i_wrp * (2 / 3)), deltimes@i, deltimes@i) \});\
	input = \cf4 In\cf3 .ar(in, 4);\
	recs = \cf4 Mix\cf3 .fill(3, \{\cf4 |i|\cf3 \
		\cf4 RecordBuf\cf3 .ar(input@i, bufs@i, loop:0.0, trigger: trigs@i);\
	\});\
	output = \cf4 Mix\cf3 .fill(3, \{\cf4 |i|\cf3 \
		\cf4 Warp1\cf3 .ar(1, bufs@i, ptrs@i, frq, wsz, -1, dns, rnd)\
			* \cf4 EnvGen\cf3 .kr(\
				\cf4 Env\cf3 ([0.0,1.0,1.0,0.0],[0.3,0.4,0.3],\cf5 \\sine\cf3 , 0, 3),\
				trigs.rotate(-1)@i, timeScale: 1.0 / i_wrp\
			)\
	\}) * \cf4 EnvGen\cf3 .kr(\cf4 Env\cf3 ([0.001, 1.0, 1.0, 0.001], [0.3, 0.4, 0.3], \cf5 \\sine\cf3 , 2, 1), gate, doneAction: 2);\
	\cf4 Out\cf3 .ar(out, \
		\cf4 A2B\cf3 .ar(\
			output,\
			\cf4 DelayN\cf3 .ar(output, 0.01, 0.01),\
			\cf4 DelayN\cf3 .ar(output, 0.02, 0.02),\
			\cf4 DelayN\cf3 .ar(output, 0.03, 0.03)\
		) * amp\
	)\
\}).add;\
\pard\pardeftab720\ql\qnatural
\cf3 \
\cf4 SynthDef\cf3 (\cf5 \\swarpfld\cf3 , \{\cf4 |out, efx, amp, gate, aamp, eamp, dur, buf, str, end, wrp, frq, wsz, dns, rnd, \
		doneAction = 2|\cf3 \
	\cf4 var\cf3  ptr, sig, env;\
	env = \cf4 EnvControl\cf3 .kr(\cf5 \\env\cf3 , 16);	\
	ptr = \cf4 LFSaw\cf3 .kr(wrp).range(str, end);\
	sig = \cf4 SndWarp\cf3 .ar(buf, ptr, frq, wsz, dns, rnd) * \
		\cf4 EnvGen\cf3 .kr(env, gate, timeScale: dur, doneAction: doneAction);\
	sig = \cf4 LeakDC\cf3 .ar(sig ** 0.5);\
	\cf4 Out\cf3 .ar(efx, sig * eamp);\
	\cf4 Out\cf3 .ar(out, sig * aamp * amp);\
\}).add;\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardeftab720\ql\qnatural\pardirnatural
\cf3 \
\pard\pardeftab720\ql\qnatural
\cf4 SynthDef\cf3 (\cf5 \\rwarpfld\cf3 , \{\cf4 |out, efx, amp, gate, aamp, eamp, dur, buf, str, end, wrp, frq, wsz, dns, rnd, \
		doneAction = 2|\cf3 \
	\cf4 var\cf3  ptr, sig, env, bf;\
	env = \cf4 EnvControl\cf3 .kr(\cf5 \\env\cf3 , 16);	\
	ptr = \cf4 LFSaw\cf3 .kr(wrp).range(str, end);\
	sig = \cf4 LeakDC\cf3 .ar(\cf4 Warp1\cf3 .ar(1, buf, ptr, frq, wsz, -1, dns, rnd)) * \
		\cf4 EnvGen\cf3 .kr(env, gate, timeScale: dur, doneAction: doneAction);\
	sig = \cf4 LeakDC\cf3 .ar(sig ** 0.5);\
	\cf4 Out\cf3 .ar(efx, sig * eamp);\
	\cf4 Out\cf3 .ar(out, sig * aamp * amp)\
\}).add;\
\
\cf4 SynthDef\cf3 (\cf5 \\atkencodedel\cf3 , \{\cf4 |out, in|\cf3 \
	\cf4 var\cf3  src, del, azm, elv, sig, a, b, c, d;\
	src = \cf4 In\cf3 .ar(in);\
	del = \cf4 ArrayControl\cf3 .kr(\cf5 \\del\cf3 , 4, 1);\
	azm = \cf4 ArrayControl\cf3 .kr(\cf5 \\azm\cf3 , 4, 1);\
	elv = \cf4 ArrayControl\cf3 .kr(\cf5 \\elv\cf3 , 4, 1);\
	sig = \cf4 Array\cf3 .fill(4, \{\cf4 |i|\cf3 \
		\cf4 DelayC\cf3 .ar(src, delaytime: del@i)\
	\});\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardeftab720\ql\qnatural\pardirnatural
\cf3 	 a = \cf4 BLowShelf\cf3 .ar(\cf4 AtkMonoToB\cf3 .ar(sig@0, azm@0, elv@0), 100.0, 0.65, 0.0);\
	 b = \cf4 BPeakEQ\cf3 .ar(\cf4 AtkMonoToB\cf3 .ar(sig@1, azm@1, elv@1), 600.0, 2.0, 0.0 );\
	 c = \cf4 BPeakEQ\cf3 .ar(\cf4 AtkMonoToB\cf3 .ar(sig@2, azm@2, elv@2), 2000.0, 2.0, 0.0 );\
	 d = \cf4 BHiShelf\cf3 .ar(\cf4 AtkMonoToB\cf3 .ar(sig@3, azm@3, elv@3), 7500.0, 1, 0.0 );\
	 \cf4 Out\cf3 .ar(out, a + b + c + d);\
\pard\pardeftab720\ql\qnatural
\cf3 \}).add;\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardeftab720\ql\qnatural\pardirnatural
\cf3 \
\pard\pardeftab720\ql\qnatural
\cf4 SynthDef\cf3 (\cf5 \\atk_trans\cf3 , \{\cf4 |out, in, xang = 0.0, yang = 0.0, zang = 0.0, \
	zoom = 0.0, push = 0.0, focus = 0.0 |\cf3 \
	\cf4 var\cf3  w, x, y, z;\
	#w, x, y, z = \cf4 In\cf3 .ar(in, 4);\
	#w, x, y, z = \cf4 AtkTilt\cf3 .ar(w, x, y, z, xang );\
	#w, x, y, z = \cf4 AtkTumble\cf3 .ar(w, x, y, z, yang );\
	#w, x, y, z = \cf4 AtkRotate\cf3 .ar(w, x, y, z, zang );\
	\cf4 Out\cf3 .ar(out, [w, x, y, z])\
\}).add;\
\
\cf2 // zone 2\cf3 \
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural\pardirnatural
\cf3 ~z3defs = [	\
	\cf4 SynthDef\cf3 (\cf5 \\kck\cf3 , \{\cf4 |ou, ef, fr, at, dr, cr, az, ea, on, am, aa|\cf3 \
		\cf4 var\cf3  sig, env, bfr;\
		env = \cf4 Env\cf3 .perc(at, 1.0 - at, 1, cr);\
		sig = \cf4 BLowPass\cf3 .ar(\
			\cf4 Mix\cf3 (\
				\cf4 SinOsc\cf3 .ar(\
					\cf4 Array\cf3 .series(5, fr, 10) * \cf4 LFNoise0\cf3 .ar(1000.0).range(35/36, 36/35), \
					0.5pi \
				)\
			),\
			300.0,\
			1.0\
		) * \cf4 EnvGen\cf3 .kr(env, timeScale: dr, levelScale: am, doneAction: 2) * on;\
		\cf4 Out\cf3 .ar(ef, sig * ea);\
		bfr = \cf4 BFEncode1\cf3 .ar(sig, az, 0, 0.5);\
		\cf4 Out\cf3 .ar(ou, bfr * aa)\
	\}),\
	\
	\
	\cf4 SynthDef\cf3 (\cf5 \\snr\cf3 , \{\cf4 |ou, fr, at, dr, cr, dc, dl, wt, az, am, aa|\cf3 \
		\cf4 var\cf3  sig, env, bfr, nr;\
		nr = 5;\
		env = \cf4 Env\cf3 .perc(at, 1.0 - at, 1, cr);\
		sig = \cf4 Dust\cf3 .ar(fr, dc * 0.5) + \cf4 BPF\cf3 .ar(\cf4 WhiteNoise\cf3 .ar, \cf4 Line\cf3 .kr(fr*1.5, fr*0.667, dr), 0.5) \
			* \cf4 EnvGen\cf3 .kr(env, timeScale: dr, doneAction: 2);\
		bfr = \cf4 BFEncode1\cf3 .ar(sig, az, 0, 0.5);\
		\cf4 Out\cf3 .ar(ou, bfr * am * aa)\
	\}),\
		\
	\cf4 SynthDef\cf3 (\cf5 \\hh\cf3 , \{\cf4 |ou, dr, fr, az, am, aa|\cf3 \
		\cf4 var\cf3  sig, env, bfr;\
		env = \cf4 EnvGen\cf3 .kr(\cf4 Env\cf3 .perc(0.05, 0.95, 1, -16), timeScale: dr, doneAction: 2);\
		sig = \cf4 RHPF\cf3 .ar(\cf4 PinkNoise\cf3 .ar, fr, 0.3) * env;\
		bfr = \cf4 BFEncode1\cf3 .ar(sig, az, 0, 0.5);	\
		\cf4 Out\cf3 .ar(ou, bfr * am * aa);\
	\}),\
	\
	\cf4 SynthDef\cf3 (\cf5 \\bss\cf3 , \{\cf4 |ou, fr, dr, az, am, aa|\cf3 \
		\cf4 var\cf3  env, sig, bfr;\
		env = \cf4 Env\cf3 ([0.001, 1.0, 1.0, 0.001], [0.01, 0.8, 0.19], \cf5 \\sine\cf3 );\
		sig = \cf4 SinOsc\cf3 .ar(fr * \cf4 LFNoise2\cf3 .ar(\cf4 SinOsc\cf3 .ar(1, 0, 500, 10000)).range(15/16, 16/15), \
			\cf4 SinOsc\cf3 .kr(2.25, 0, pi, pi), 10).distort\
			* \cf4 EnvGen\cf3 .kr(env, timeScale: dr, doneAction: 2);\
		sig = \cf4 Reverb\cf3 .ar(sig * 0.1, 3) + sig;\
		sig = \cf4 Compander\cf3 .ar(sig, sig, 0.2, 1.0, 0.01);\
		bfr = \cf4 BFEncode1\cf3 .ar(sig, az, 0, 0.5);\
		\cf4 Out\cf3 .ar(ou, bfr * am * aa)\
	\}),\
	\
	\cf4 SynthDef\cf3 (\cf5 \\clck\cf3 , \{\cf4 |ou, ef, am, az, dr, bt, ea, aa|\cf3 \
		\cf4 var\cf3  sig, bfr;\
		sig = \cf4 BPF\cf3 .ar(\
			\cf4 VarSaw\cf3 .ar(15000, 0.0, 0.1, \cf4 Decay\cf3 .ar(\cf4 Impulse\cf3 .ar(bt), 0.001)),\
			15000,\
			0.9,\
			25 * \cf4 LFNoise1\cf3 .ar(8).range(0, 1)\
		).fold(-1, 1);\
		sig = sig * \cf4 EnvGen\cf3 .kr(\cf4 Env\cf3 ([0, 1, 1, 0], [0, 1, 0]), timeScale: dr, doneAction: 2);\
		\cf4 Out\cf3 .ar(ef, sig * ea);\
		bfr = \cf4 BFEncode1\cf3 .ar(sig, az, 0, 0.5);\
		\cf4 Out\cf3 .ar(ou, bfr * am * aa)\
	\}),\
			\
	\cf4 SynthDef\cf3 (\cf5 \\nzsnr\cf3 , \{\cf4 |ou, am, az, fr, dr, aa|\cf3 \
		\cf4 var\cf3  sig, env, bfr;\
		env = \cf4 EnvGen\cf3 .kr(\cf4 Env\cf3 .perc(0.05, 0.95, 1, -16), timeScale: dr, doneAction: 2);\
		sig = \cf4 Dust\cf3 .ar(fr) * \cf4 SinOsc\cf3 .ar(fr) * env;\
		bfr = \cf4 BFEncode1\cf3 .ar(sig, az, 0, 0.5);\
		\cf4 Out\cf3 .ar(ou, bfr * am * aa);\
	\}),\
	\
	\cf4 SynthDef\cf3 (\cf5 \\pnk\cf3 , \{\cf4 |ou, az, dr, am, aa|\cf3 \
		\cf4 var\cf3  sig, env, bfr;\
		env = \cf4 EnvGen\cf3 .kr(\cf4 Env\cf3 .perc(0.05, 0.95, 1, -16), timeScale: dr, doneAction: 2);\
		sig = \cf4 PinkNoise\cf3 .ar * env;\
		bfr = \cf4 BFEncode1\cf3 .ar(sig, az, 0, 0.5);\
		\cf4 Out\cf3 .ar(ou, bfr * am * aa)\
	\}),\
	\
	\cf4 SynthDef\cf3 (\cf5 \\fmsnth\cf3 , \{\cf4 |ou, ef, dr, gd, cf, mf, in, az, on, am, aa|\cf3 \
		\
		\cf4 var\cf3  sig, env, bfr, trg, dev, amps, n = 7;\
		trg = \cf4 Impulse\cf3 .kr(gd.reciprocal);\
		env = \cf4 Env\cf3 ([0.001, 1.0, 1.0, 0.001], [0.1, 0.5, 0.4], [0, 0, 3]);\
		dev = \cf4 Array\cf3 .rand(n, 0.5, 2.0).round(1 - (2**(1/24)));\
		amps = \cf4 Array\cf3 .geom(n, 1.0, 13 / 21);\
		sig = \cf4 Mix\cf3 .fill(n, \{\cf4 |i|\cf3 \
			\cf4 var\cf3  frq = cf * dev[i];\
			\cf4 DelayC\cf3 .ar(\cf4 FMGrain\cf3 .ar(trg, gd, frq, frq * mf, in, amps[i]), 0.1, \cf4 Rand\cf3 (0, 0.1))\
		\}) * \cf4 EnvGen\cf3 .kr(env, timeScale: dr, doneAction: 2);\
		bfr = \cf4 BFEncode1\cf3 .ar(sig * am, az, 0, 0.5);\
		\cf4 Out\cf3 .ar(ou, bfr * aa)	\
	\}),\
	\
	\cf4 SynthDef\cf3 (\cf5 \\hgls\cf3 , \{\cf4 |ou, dr, fr, wd, ws, wr, gr, az, on, am, aa|\cf3 \
		\
		\cf4 var\cf3  sig, env, bfr;\
		env = \cf4 Env\cf3 ([0.001, 1.0, 1.0, 0.001], [0.2, 0.5, 0.3], \cf5 \\sine\cf3 );\
		sig = \cf4 VarSaw\cf3 .ar(\cf4 XLine\cf3 .kr(fr, fr * 0.5, dr), 0, wd);\
		sig = \cf4 GrainIn\cf3 .ar(1, \cf4 Impulse\cf3 .kr(gr * \cf4 TRand\cf3 .kr(1-wr, 1+wr, \cf4 Impulse\cf3 .kr(gr))), ws, sig) * \
			\cf4 EnvGen\cf3 .kr(env, timeScale: dr, doneAction: 2);\
		bfr = \cf4 BFEncode1\cf3 .ar(sig * am, az, 0, 0.5);\
		\cf4 Out\cf3 .ar(ou, bfr * aa)\
		\
	\}),\
\
	\cf4 SynthDef\cf3 (\cf5 \\dbkck\cf3 , \{\cf4 |ou, ef, dr, gd, az, ea, on, am, aa|\cf3 \
		\cf4 var\cf3  sig, env, bfr, fr;\
		fr = \cf4 Array\cf3 .geom(24, 14.midicps, 2**(1/24)) * (1..4).stutter(6).reverse;\
		env = \cf4 Env\cf3 ([0.001, 8.0, 1.0, 0.001], [0.01, 0.1, 0.89], [0, 0, -16]);\
		sig = \cf4 Mix\cf3 (\cf4 SinGrain\cf3 .ar(\cf4 Impulse\cf3 .kr(gd.reciprocal * 4), gd, fr, 0.4)); \
		sig = sig * \cf4 EnvGen\cf3 .kr(env, timeScale: dr, doneAction: 2);\
		sig = sig.clip(-0.9, 0.9);\
		\cf4 Out\cf3 .ar(ef, sig * ea);\
		bfr = \cf4 BFEncode1\cf3 .ar(sig * am, az, 0, 0.5);\
		\cf4 Out\cf3 .ar(ou, bfr * aa)\
	\
	\}),\
	\
	\cf4 SynthDef\cf3 (\cf5 \\dbclp\cf3 , \{\cf4 |ou, ef, at, dc, cr, dr, co, ds, az, ea, on, am, aa|\cf3 \
		\cf4 var\cf3  sig, env, bfr;\
		env = \cf4 Env\cf3 .perc(at, dc, 1, cr);\
		sig = \cf4 Crackle\cf3 .ar(co, ds).clip(-0.9, 0.9) * \
			\cf4 EnvGen\cf3 .kr(env, timeScale: dr, doneAction: 2);\
		\cf4 Out\cf3 .ar(ef, sig * ea);\
		bfr = \cf4 BFEncode1\cf3 .ar(sig * am, az, 0, 0.5);\
		\cf4 Out\cf3 .ar(ou, bfr * aa)\
	\}),\
	\
	\cf4 SynthDef\cf3 (\cf5 \\gndy\cf3 , \{\cf4 |ou, at, cr, dr, sf, ef, az, am|\cf3 \
		\cf4 var\cf3  sig, bfr;\
		sig = \cf4 Gendy3\cf3 .ar(freq: \cf4 XLine\cf3 .kr(sf, ef, dr)) * \cf4 EnvGen\cf3 .kr(\cf4 Env\cf3 .perc(at, 1 - at, 1, cr), timeScale: dr, doneAction: 2);\
		bfr = \cf4 BFEncode1\cf3 .ar(sig * am, az, 0, 0.5);\
		\cf4 Out\cf3 .ar(ou, bfr)\
	\}),\
	\
	\cf4 SynthDef\cf3 (\cf5 \\bpst\cf3 , \{\cf4 |ou, at, cr, dr, fr, az, am|\cf3 \
		\cf4 var\cf3  sig, bfr;\
		sig = \cf4 KmeansToBPSet1\cf3 .ar(freq: fr) * \cf4 EnvGen\cf3 .kr(\cf4 Env\cf3 .perc(at, 1 - at, 1, cr), timeScale: dr, doneAction: 2);\
		bfr = \cf4 BFEncode1\cf3 .ar(sig * am, az, 0, 0.5);\
		\cf4 Out\cf3 .ar(ou, bfr)\
	\}),\
	\
	\cf4 SynthDef\cf3 (\cf5 \\lrnz\cf3 , \{\cf4 |ou, nf, xf, at, cr, dr, az, am|\cf3 \
		\cf4 var\cf3  sig, bfr;\
		sig = \cf4 Lorenz2DC\cf3 .ar(nf, xf).clip(-1, 1) * \cf4 EnvGen\cf3 .kr(\cf4 Env\cf3 .perc(at, 1 - at, 1, cr), timeScale: dr, doneAction: 2);\
		bfr = \cf4 BFEncode1\cf3 .ar(sig * am, az, 0, 0.5);\
		\cf4 Out\cf3 .ar(ou, bfr)\
	\}),\
	\
	\cf4 SynthDef\cf3 (\cf5 \\stnd\cf3 , \{\cf4 |ou, nf, xf, pr, at, cr, dr, az, am|\cf3 \
		\cf4 var\cf3  sig, bfr;\
		sig = \cf4 Standard2DL\cf3 .ar(nf, xf, pr) * \cf4 EnvGen\cf3 .kr(\cf4 Env\cf3 .perc(at, 1 - at, 1, cr), timeScale: dr, doneAction: 2);\
		bfr = \cf4 BFEncode1\cf3 .ar(sig * am, az, 0, 0.5);\
		\cf4 Out\cf3 .ar(ou, bfr.clip(-1, 1))\
	\}),\
	\
	\cf4 SynthDef\cf3 (\cf5 \\latoo\cf3 , \{\cf4 |ou, nf, xf, at, cr, dr, az, am|\cf3 \
		\cf4 var\cf3  sig, bfr;\
		sig = \cf4 Latoocarfian2DN\cf3 .ar(nf, xf) * \cf4 EnvGen\cf3 .kr(\cf4 Env\cf3 .perc(at, 1 - at, 1, cr), timeScale: dr, doneAction: 2);\
		bfr = \cf4 BFEncode1\cf3 .ar(sig * am, az, 0, 0.5);\
		\cf4 Out\cf3 .ar(ou, bfr)\
	\})	\
	\
];\
\
~z3defs.do(\cf4 _\cf3 .add);\
\
\pard\pardeftab720\ql\qnatural
\cf4 SynthDef\cf3 (\cf5 \\rwarpfldatk\cf3 , \{\cf4 |out, efx, gate, aamp, eamp, maxdel, dur, buf, str, end, wrp, frq, wsz, \
		dns, rnd, xang, yang, zang, doneAction = 2|\cf3 \
	\cf4 var\cf3  ptr, sig, bf, delays, shifts, wins, amps, a, b, c, d, w, x, y, z;\
	delays = \cf4 ArrayControl\cf3 .kr(\cf5 \\delays\cf3 , 4, 0);\
	shifts = \cf4 ArrayControl\cf3 .kr(\cf5 \\shifts\cf3 , 4, 1);\
	wins = \cf4 ArrayControl\cf3 .kr(\cf5 \\wins\cf3 , 4, 0.1);\
	amps = \cf4 ArrayControl\cf3 .kr(\cf5 \\amps\cf3 , 4, 1);\
	ptr = \cf4 LFSaw\cf3 .kr(wrp).range(str, end);\
	sig = \cf4 LeakDC\cf3 .ar(\cf4 Warp1\cf3 .ar(1, buf, ptr, frq, wsz, -1, dns, rnd)) * \
		\cf4 EnvGen\cf3 .kr(\cf4 EnvControl\cf3 .kr, gate, timeScale: dur, doneAction: doneAction);\
	sig = \cf4 LeakDC\cf3 .ar(sig ** 0.5 ** 1.5);\
	\cf4 Out\cf3 .ar(efx, sig * eamp);\
	#a, b, c, d = \cf4 Array\cf3 .fill(4, \{\cf4 |i|\cf3   \
		\cf4 DelayC\cf3 .ar(\cf4 PitchShift\cf3 .ar(sig, wins@i, shifts@i), maxdel, delays@i, amps@i);\
	\});\
	#w, x, y, z = \cf4 A2B\cf3 .ar(a, b, c, d);\
	\cf4 Out\cf3 .ar(out, \cf4 AtkRotateXYZ\cf3 .ar(w, x, y, z, xang, yang, zang) * aamp)\
\}).add;\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural\pardirnatural
\cf3 \
\pard\pardeftab720\ql\qnatural
\cf4 SynthDef\cf3 (\cf5 \\zone3_doublemono\cf3 , \{\cf4 |out, efx, gate = 1, amp, start = 0, eamp, bufL, bufR, azm, wid, elv, dur, \
		xang, yang, zang|\cf3 \
     	\cf4 var\cf3  l, r, env;\
     	env = \cf4 EnvControl\cf3 .kr;\
     	l = \cf4 PlayBuf\cf3 .ar(1, bufL, 1, 1, start);\
     	r = \cf4 PlayBuf\cf3 .ar(1, bufR, 1, 1, start);\
     	\cf4 Out\cf3 .ar(efx, (l * 0.7) + (r * 0.7));\
     	#w, x, y, z = \cf4 AtkSterToB\cf3 .ar(l, r, azm, wid, elv) \
     		* \cf4 EnvGen\cf3 .kr(env, gate, timeScale: dur, doneAction: 2);\
     	\cf4 Out\cf3 .ar(out, \cf4 AtkRotateXYZ\cf3 .ar(w, x, y, z, xang, zang, yang) * amp)\
\}).add;\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural\pardirnatural
\cf4 SynthDef\cf3 (\cf5 \\kckrv\cf3 , \{\cf4 |ou, in, rt, am, az|\cf3 \
	\cf4 var\cf3  inp, sig, bfr;\
	inp = \cf4 In\cf3 .ar(in);\
	sig = \cf4 GVerb\cf3 .ar(inp, 10, rt, 0.1, 0.1, 1);\
	bfr = \cf4 BFEncode1\cf3 .ar(sig[0], az, 0, 0.5);\
	\cf4 Out\cf3 .ar(ou, bfr * am)\
\}).add;\
\
\cf2 // zone 3\cf3 \
\
\cf4 SynthDef\cf3 (\cf5 \\zone3fxwarp\cf3 , \{\cf4 |out, efx, buf, trg, ptr, tdur, frq, wsz, dns, ratio, rate, pulse, amp, aamp, eamp, rev, rtime, gate, azm, xang, yang, zang|\cf3 \
	\cf4 var\cf3  sig, env, rL, rR, w, x, y, z, frqs, rqs, dbs, tenv;\
	frqs = \cf4 Array\cf3 .geom(4, exp(1)**4, 5);\
	rqs = \cf4 Array\cf3 .geom(4, 0.5, 1.618);\
	dbs = \cf4 Array\cf3 .fill(4, \{\cf4 |i|\cf3  \cf4 AmpCompA\cf3 .ir(frqs[i]).ampdb\});\
	tenv = \cf4 EnvGen\cf3 .kr(\cf4 Env\cf3 ([1, 1, 0], (tdur * 0.5) ! 2), \cf4 InTrig\cf3 .kr(trg)) * amp;\
	env = \cf4 EnvGen\cf3 .kr(\cf4 Env\cf3 ([0.001, 1.0, 1.0, 0.001], [0.3, 0.4, 0.3], \cf5 \\sine\cf3 , 2, 1), gate, doneAction: 2);\
	sig = \cf4 Warp1\cf3 .ar(1, buf, ptr, frq, wsz, -1, dns, ratio, \
		interp: 0, mul: \cf4 LFPulse\cf3 .kr(rate, 0, 0.25).range(pulse, 1.0)) * amp * tenv;\
	\cf4 Out\cf3 .ar(efx, sig * eamp);\
	#w, x, y, z = \cf4 A2B\cf3 .ar(*\cf4 Array\cf3 .fill(4, \{\cf4 |i|\cf3 \
			\cf4 BPeakEQ\cf3 .ar(sig, frqs[i], rqs[i], dbs[i]);\
		\})\
	) * env;\
	\cf4 Out\cf3 .ar(out, \cf4 AtkRotateXYZ\cf3 .ar(w, x, y, z, xang, yang, zang) * aamp)\
\}).add;\
\
\cf4 SynthDef\cf3 (\cf5 \\zone3loop\cf3 , \{\cf4 |out, buf, start, dur, gate = 1, rate, amp, aamp, xang, yang, zang, xpush, ypush, zpush|\cf3 \
	\cf4 var\cf3  env, sig, del, w, x, y, z;\
	env = \cf4 EnvGen\cf3 .kr(\cf4 EnvControl\cf3 .kr, gate, timeScale: dur, doneAction: 2);\
	del = \cf4 ArrayControl\cf3 .kr(\cf5 \\del\cf3 , 4, 1);\
	sig = \cf4 PlayBuf\cf3 .ar(1, buf, rate, 1, start, loop: 1) * env;\
	#w, x, y, z = \cf4 A2B\cf3 .ar(\
		*\cf4 Array\cf3 .fill(4, \{\cf4 |i|\cf3 \
			\cf4 DelayC\cf3 .ar(sig, 0.1, del[i])\
		\})\
	);\
	#w, x, y, z = \cf4 AtkRotateXYZ\cf3 .ar(w, x, y, z, xang, yang, zang) * amp;\
	\cf4 Out\cf3 .ar(out, \cf4 AtkPush\cf3 .ar(w, x, y, z, xpush, ypush, zpush) * aamp)\
\}).add;\
\pard\pardeftab720\ql\qnatural
\cf3 \
\cf2 // zone 4\cf3 \
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural\pardirnatural
\cf4 SynthDef\cf3 (\cf5 \\zone4_waveTerrain\cf3 , \{\cf4 |out, efx, buffer, aa, ab, ac, ad,\
		pxa, pya, pxb, pyb, pxc, pyc, pxd, pyd, xang, yang, zang, aamp|\cf3 \
	\cf4 var\cf3  a, b, c, d, w, x, y, z, raL, raR, rcL, rcR;\
	a = \cf4 WaveTerrain\cf3 .ar(buffer, \cf4 LFSaw\cf3 .ar(pxa).range(0.0, 1.0), \cf4 LFSaw\cf3 .ar(pya).range(0.0, 1.0), 16, 16);\
	b = \cf4 WaveTerrain\cf3 .ar(buffer, \cf4 LFSaw\cf3 .ar(pxb).range(0.0, 1.0), \cf4 LFSaw\cf3 .ar(pyb).range(0.0, 1.0), 16, 16);\
	c = \cf4 WaveTerrain\cf3 .ar(buffer, \cf4 LFSaw\cf3 .ar(pxc).range(0.0, 1.0), \cf4 LFSaw\cf3 .ar(pyc).range(0.0, 1.0), 16, 16);\
	d = \cf4 WaveTerrain\cf3 .ar(buffer, \cf4 LFSaw\cf3 .ar(pxd).range(0.0, 1.0), \cf4 LFSaw\cf3 .ar(pyd).range(0.0, 1.0), 16, 16);\
	#raL, raR = \cf4 PitchShift\cf3 .ar(\cf4 GVerb\cf3 .ar(a+\cf4 Dust2\cf3 .ar(ab.linlin(0, 1, 10, 80)), 10, 15, 0.5, 0.5, 15, 0, 0.06, 0.1), 0.1, 0.5);\
	#rcL, rcR = \cf4 PitchShift\cf3 .ar(\cf4 GVerb\cf3 .ar(c+\cf4 Dust2\cf3 .ar(ad.linlin(0, 1, 10, 80)), 10, 15, 0.5, 0.5, 15, 0, 0.06, 0.1), 0.1, 2.0);\
	a = \cf4 Compander\cf3 .ar(a**0.5, a**0.5, 0.95, 0.1, 0.1) * aa;\
	b = \cf4 Compander\cf3 .ar(b**0.5, b**0.5, 0.95, 0.1, 0.1) * ab;\
	c = \cf4 Compander\cf3 .ar(c**0.5, c**0.5, 0.95, 0.1, 0.1) * ac;\
	d = \cf4 Compander\cf3 .ar(d**0.5, d**0.5, 0.95, 0.1, 0.1) * ad;\
	\cf4 Out\cf3 .ar(efx, [a, b, c, d]);\
	#a, b, c, d = [a, b, c, d] + [raL, raR, rcL, rcR];\
	#w, x, y, z = \cf4 LeakDC\cf3 .ar(\cf4 A2B\cf3 .ar(a, b, c, d));\
	\cf4 Out\cf3 .ar(out, \cf4 AtkRotateXYZ\cf3 .ar(w, x, y, z, xang, yang, zang) * aamp)\
\}).add;\
\pard\pardeftab720\ql\qnatural
\cf3 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural\pardirnatural
\cf4 SynthDef\cf3 (\cf5 \\zone04play\cf3 , \{\cf4 |out, efx, gate, buffer, ptr, genv, wrnd, dur, eamp, aamp, xang, yang, zang, amp|\cf3 \
	\cf4 var\cf3  env, pch, del, wsz, dns, a, b, c, d;\
	env = \cf4 EnvControl\cf3 .kr;\
	pch = \cf4 ArrayControl\cf3 .kr(\cf5 \\pch\cf3 , 4, 1);\
	wsz = \cf4 ArrayControl\cf3 .kr(\cf5 \\wsz\cf3 , 4, 1);\
	dns = \cf4 ArrayControl\cf3 .kr(\cf5 \\dns\cf3 , 4, 1);\
	del = \cf4 ArrayControl\cf3 .kr(\cf5 \\del\cf3 , 4, 1);\
	#a, b, c, d = \cf4 Array\cf3 .fill(4, \{\cf4 |i|\cf3 \
		\cf4 DelayN\cf3 .ar(\cf4 Warp1\cf3 .ar(1, buffer, ptr, pch[i], wsz[i], genv, dns[i], wrnd), 0.1, del[i])\
	\}) * \cf4 EnvGen\cf3 .kr(env, gate, timeScale: dur, doneAction: 2) * amp;\
	#w, x, y, z = \cf4 A2B\cf3 .ar(a, b, c, d);\
	\cf4 Out\cf3 .ar(efx, w * eamp);\
	\cf4 Out\cf3 .ar(out, \cf4 AtkRotateXYZ\cf3 .ar(w, x, y, z, xang, yang, zang) * aamp)\
\}).add;\
\
\cf4 SynthDef\cf3 (\cf5 \\zone04cycles\cf3 , \{\cf4 |out, in, gate = 1.0, i_wrp = 0.1, frq, wsz, dns, rnd, amp, \
		aa, ab, ac, ad, xang, yang, zang|\cf3 \
	\cf4 var\cf3  bufs, recs, ptrs, phases, deltimes, output, trigs, input, w, x, y, z;\
	deltimes = [0, 1 / i_wrp * 0.5, 1 / i_wrp];\
	bufs = \cf4 Array\cf3 .fill(3, \{ \cf4 LocalBuf\cf3 (\cf4 SampleRate\cf3 .ir * 2) \});\
	ptrs = \cf4 Array\cf3 .fill(3, \{\cf4 |i|\cf3  \cf4 LFSaw\cf3 .kr(i_wrp, 0, 0.5, 0.5) \});\
	trigs = \cf4 Array\cf3 .fill(3, \{\cf4 |i|\cf3  \cf4 DelayN\cf3 .kr(\cf4 Impulse\cf3 .kr(i_wrp * (2 / 3)), deltimes@i, deltimes@i) \});\
	input = \cf4 In\cf3 .ar(in, 4);\
	recs = \cf4 Mix\cf3 .fill(3, \{\cf4 |i|\cf3 \
		\cf4 RecordBuf\cf3 .ar(input@i, bufs@i, loop:0.0, trigger: trigs@i);\
	\});\
	output = \cf4 Mix\cf3 .fill(3, \{\cf4 |i|\cf3 \
		\cf4 Warp1\cf3 .ar(1, bufs@i, ptrs@i, frq, wsz, -1, dns, rnd)\
			* \cf4 EnvGen\cf3 .kr(\
				\cf4 Env\cf3 ([0.0,1.0,1.0,0.0],[0.3,0.4,0.3],\cf5 \\sine\cf3 , 0, 3),\
				trigs.rotate(-1)@i, timeScale: 1.0 / i_wrp\
			)\
	\}) * \cf4 EnvGen\cf3 .kr(\cf4 Env\cf3 ([0.001, 1.0, 1.0, 0.001], [0.3, 0.4, 0.3], \cf5 \\sine\cf3 , 2, 1), gate, doneAction: 2);\
	#w, x, y, z = \cf4 A2B\cf3 .ar(\
		output * aa,\
		\cf4 DelayN\cf3 .ar(output, 0.01, 0.01) * ab,\
		\cf4 DelayN\cf3 .ar(output, 0.02, 0.02) * ac,\
		\cf4 DelayN\cf3 .ar(output, 0.03, 0.03) * ad\
	);\
	\cf4 Out\cf3 .ar(out, \cf4 AtkRotateXYZ\cf3 .ar(w, x, y, z, xang, yang, zang) * amp)\
\}).add;\
\
\pard\pardeftab720\ql\qnatural
\cf3 \
\cf2 // zone 5\cf3 \
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural\pardirnatural
\cf4 SynthDef\cf3 (\cf5 \\zone5_play\cf3 , \{\cf4 |out, efx, efrq, eamp, gate, buffer, dur, amp, pch1, pch2, pch3, wsz, dns, xang, yang, zang|\cf3   \
	\cf4 var\cf3  env, envdel, pitch, times, warps, w, x, y, z;\
	envdel = \cf4 ArrayControl\cf3 .kr(\cf5 \\envdel\cf3 , 4, 1);\
	warps = \cf4 ArrayControl\cf3 .kr(\cf5 \\warps\cf3 , 4, 1);\
	times = \cf4 ArrayControl\cf3 .kr(\cf5 \\times\cf3 , 4, 1);\
	pitch = [1, pch1, pch2, pch3];\
	#w, x, y, z = \cf4 A2B\cf3 .ar(\
		*\cf4 Array\cf3 .fill(4, \{\cf4 |i|\cf3 \
			\cf4 DelayN\cf3 .ar(\
				\cf4 Warp1\cf3 .ar(1, buffer, \cf4 LFSaw\cf3 .kr(warps@i, 1, 0.5, 0.5), pitch@i, wsz, -1, dns) \
					* \cf4 EnvGen\cf3 .kr(\cf4 Env\cf3 ([0.001, 1.0, 1.0, 0.001], [0.1, 0.8, 0.1], \cf5 \\sine\cf3 ), gate, timeScale: times@i), \
				envdel@i, \
				envdel@i\
			)\
		\})\
	) * \cf4 EnvGen\cf3 .kr(\cf4 Env\cf3 ([1, 1, 0], [0.9, 0.1], \cf5 \\sine\cf3 ), gate, timeScale: dur);\
	\cf4 Out\cf3 .ar(efx, \cf4 RLPF\cf3 .ar(w, efrq) * eamp);\
	\cf4 Out\cf3 .ar(out, \cf4 AtkRotateXYZ\cf3 .ar(w, x, y, z, xang, yang, zang) * amp)\
\}).add;\
\
\cf4 SynthDef\cf3 (\cf5 \\zone5_distort\cf3 , \{\cf4 |out, efx, eamp, buf, amp, dur, wrp, frq, wsz = 0.1, dns = 4, bzf = 12, dep = 0.25, pwsz|\cf3 \
	\cf4 var\cf3  sig, w, x, y, z, xang, yang, zang, del, pch;\
	pch = \cf4 ArrayControl\cf3 .kr(\cf5 \\pch\cf3 , 4, 1);\
	del = \cf4 ArrayControl\cf3 .kr(\cf5 \\del\cf3 , 4, 1);\
	xang = \cf4 EnvGen\cf3 .kr(\cf4 EnvControl\cf3 .kr(\cf5 \\xang\cf3 ), timeScale: dur);\
	yang = \cf4 EnvGen\cf3 .kr(\cf4 EnvControl\cf3 .kr(\cf5 \\yang\cf3 ), timeScale: dur);\
	zang = \cf4 EnvGen\cf3 .kr(\cf4 EnvControl\cf3 .kr(\cf5 \\zang\cf3 ), timeScale: dur);\
	sig = tanh(\cf4 Warp1\cf3 .ar(1, buf, \cf4 LFSaw\cf3 .kr(wrp, 1, 0.5, 0.5), frq, wsz, -1, dns).distort ** 0.5 *\
		\cf4 XLine\cf3 .kr(0.001, amp, dur, doneAction: 2)) * 0.99;\
	sig = sig * \cf4 Saw\cf3 .kr(bzf).range(dep, 1);\
	\cf4 Out\cf3 .ar(efx, sig * eamp);\
	#w, x, y, z = \cf4 A2B\cf3 .ar(\
		*\cf4 Array\cf3 .fill(4, \{\cf4 |i|\cf3 \
			\cf4 DelayC\cf3 .ar(\cf4 PitchShift\cf3 .ar(sig, pwsz, pch@i), del@i, del@i)\
		\})\
	);\
	\cf4 Out\cf3 .ar(out, \cf4 AtkRotateXYZ\cf3 .ar(w, x, y, z, xang, yang, zang))\
\}).add;\
\pard\pardeftab720\ql\qnatural
\cf3 \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural\pardirnatural
\cf4 SynthDef\cf3 (\cf5 \\point\cf3 , \{\cf4 |out, buf, tb, gate, amp, tfr, afr, sln, sfr, sam, rmp, rtm, doneAction|\cf3 \
	\cf4 var\cf3  sig = 0, trg, azm, elv, enc, dst, s_freqs, s_amps, s_sig, env, clk, atrg, rev;\
	env = \cf4 EnvControl\cf3 .kr(\cf5 \\env\cf3 );\
	dst = \cf4 LFTri\cf3 .kr(afr).range(1.0, 2.0);\
	azm = \cf4 Dseq\cf3 ([-0.25, 0.25] * pi, \cf4 inf\cf3 );\
	elv = \cf4 Dstutter\cf3 (2, \cf4 Dseq\cf3 ([0.25, -0.25], \cf4 inf\cf3 ));\
	trg = \cf4 InTrig\cf3 .kr(tb);\
	atrg = \cf4 K2A\cf3 .ar(trg);\
	sig = \cf4 PlayBuf\cf3 .ar(1, buf, trigger: trg) ** dst;\
	clk = \cf4 Mix\cf3 (\
		\cf4 BPF\cf3 .ar(\
\pard\pardeftab720\ql\qnatural
\cf3 		\cf4 PinkNoise\cf3 .ar(\cf4 Decay\cf3 .ar(atrg, 0.001 * \cf4 LFNoise1\cf3 .ar(4).abs)),\
		15000,\'a0\
		0.9,\'a0\
		25 * \cf4 LFNoise1\cf3 .ar(8).range(0, 1)\'a0\
		).fold(-1, 1)\
     );	\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural\pardirnatural
\cf3 	s_sig = \cf4 SinOsc\cf3 .ar(sfr, 0, sam) \
		* \cf4 EnvGen\cf3 .kr(\cf4 Env\cf3 ([0.001, 1.0, 1.0, 0.001], [0.0, 0.9, 0.1]), \
			\cf4 PulseDivider\cf3 .ar(trg, 2.0), timeScale: sln);\
	#sig, rev = \cf4 DistAmp\cf3 .ar(sig + s_sig + clk, dst, rmp);\
	sig = sig + \cf4 Reverb\cf3 .ar(rev, rtm);\
	enc = \cf4 BFEncode1\cf3 .ar(sig * amp, \cf4 Demand\cf3 .kr(trg, 0, azm), \cf4 Demand\cf3 .kr(trg, 0, elv) );\
	\cf4 Out\cf3 .ar(out, enc * \cf4 EnvGen\cf3 .kr(env, gate, doneAction: doneAction))\
\}).add;\
\
\
\cf2 // PATTERNS\cf3 \
\
\cf4 SynthDef\cf3 (\cf5 \\pat03play\cf3 , \{\cf4 |out, trgin, bufferA, bufferB, bdur, del, dec, rtm, spr, rev, tail, \
		xang, yang, zang, azm, wid, gate=1|\cf3 \
	\cf4 var\cf3  w, x, y, z, trg, cmb, vrbL, vrbR, sig, a, b, c, d, env, bss;\
	env = \cf4 EnvGen\cf3 .kr(\cf4 EnvControl\cf3 .kr, gate, doneAction: 2);\
	trg = \cf4 InTrig\cf3 .kr(trgin);\
	#a, b = \cf4 CombC\cf3 .ar(\cf4 PlayBuf\cf3 .ar(2, bufferA, loop: 1) \
		* \cf4 EnvGen\cf3 .kr(\cf4 Env\cf3 .perc, trg, timeScale: bdur, levelScale: trg), del, del, dec); \
	#c, d = \cf4 CombC\cf3 .ar(\cf4 PlayBuf\cf3 .ar(2, bufferB, loop: 1) \
		* \cf4 EnvGen\cf3 .kr(\cf4 Env\cf3 .perc, trg, timeScale: bdur, levelScale: trg), del, del, dec);\
	#w, x, y, z = \cf4 A2B\cf3 .ar(a, b, c, d) * env;\
	#vrbL, vrbR = \cf4 GVerb\cf3 .ar(w, 100, rtm, 0.5, 0.5, spr, 0, rev, tail) * env;\
	\cf4 Out\cf3 .ar(out, \cf4 AtkRotateXYZ\cf3 .ar(w, x, y, z, xang, yang, zang) \
		+ \cf4 AtkSterToB\cf3 .ar(vrbL, vrbR, azm, wid) \
	)\
\}).add;\
\
\cf4 SynthDef\cf3 (\cf5 \\pat04play\cf3 , \{\cf4 |out, intr, gate=1.0, dur, frq, amp, room, rtm, early, tail, hfq, xang, yang, zang|\cf3 \
	\cf4 var\cf3  trg, pat, intrg, sig, note, swr, sweep, bt, gap, output, pchs, w, x, y, z;\
	pchs = \cf4 Array\cf3 .geom(4, 35/36**3, 36/35);\
	pat = \cf4 Dseq\cf3 (\cf4 ArrayControl\cf3 .kr(\cf5 \\pulse\cf3 , 16, 1), \cf4 inf\cf3 );\
	swr = \cf4 Dxrand\cf3 ([2, 4, 4, 4, 8, 8, 16], \cf4 inf\cf3 );\
	intrg = \cf4 InTrig\cf3 .kr(intr);\
	trg = \cf4 PulseDivider\cf3 .kr(intrg, \cf4 Demand\cf3 .kr(\cf4 LocalIn\cf3 .kr, 0, pat));\
	\cf4 LocalOut\cf3 .kr(trg);\
	note = \cf4 Demand\cf3 .kr(trg, 0, \cf4 Dxrand\cf3 (\cf4 Array\cf3 .geom(7, pi**3, 2**(1/24)), \cf4 inf\cf3 ));\
	gap = \cf4 Timer\cf3 .kr(trg);\
	sweep = \cf4 LFTri\cf3 .ar(gap * \cf4 Demand\cf3 .kr(trg, 0, swr)).exprange(40, 1000);\
	sig = \cf4 LPF\cf3 .ar(\cf4 LFSaw\cf3 .ar(note * [35/36, 1, 36/35], 0, \cf4 LFPulse\cf3 .kr(\cf4 Demand\cf3 .kr(trg, 0, swr) * gap).range(0.5, 1.0)).sum, sweep);\
	sig = sig + \cf4 BPF\cf3 .ar(sig, 1000, 2);\
	sig = sig + \cf4 GVerb\cf3 .ar(sig.distort, 20, 2, 0.7, mul: 0.2).sum;\
	sig = sig + \cf4 SinOsc\cf3 .ar(note, 0, \cf4 LFTri\cf3 .ar(gap,mul:2,add:1)).tanh * 0.5;\
\cf2 //	bt = HPF.ar(CombN.ar(Decay.ar(Trig1.ar(trg, 0.05), 0.1, 20).clip2, 1, gap * 2, 1), hfq, 4);\cf3 \
\cf2 //	bt = bt + GVerb.ar(bt, room, rtm, 0.5, 0.5, 15, 0, early, tail, mul: 0.3).sum;\cf3 \
	output = (sig) * \cf4 EnvGen\cf3 .kr(\cf4 EnvControl\cf3 .kr, gate, timeScale: dur, doneAction: 2);\
	#w, x, y, z = \cf4 AtkMonoToB\cf3 .ar(output);\
	\cf4 Out\cf3 .ar(out, \cf4 AtkRotateXYZ\cf3 .ar(w, x, y, z, xang, yang, zang) * amp)\
\}).add;\
\
\cf4 SynthDef\cf3 (\cf5 \\pat04point\cf3 , \{\cf4 |out, efx, buf, amp, dur, eamp, pls, xang, yang, zang|\cf3 \
	\cf4 var\cf3  sig, w, x, y, z;\
	sig = \cf4 MulAdd\cf3 (\cf4 PlayBuf\cf3 .ar(1, buf), \cf4 LFPulse\cf3 .ar(pls).range(0,1)) ** 0.5 \
		* \cf4 EnvGen\cf3 .kr(\cf4 EnvControl\cf3 .kr, timeScale: dur, doneAction: 2);\
	\cf4 Out\cf3 .ar(efx, sig * eamp);\
	#w, x, y, z = \cf4 AtkMonoToB\cf3 .ar(sig * amp);\
	\cf4 Out\cf3 .ar(out, \cf4 AtkRotateXYZ\cf3 .ar(w, x, y, z, xang, yang, zang))\
\}).add;\
\
\cf4 SynthDef\cf3 (\cf5 \\pat05saw\cf3 , \{\cf4 |out, efx, aamp, eamp, dur, rate, off, buffer, xang, yang, zang|\cf3 \
	\cf4 var\cf3  sig, env, frqs, amps, parts, a, b, c, d, w, x, y, z, pointer;\
	parts = (0..199);\
	env = \cf4 EnvControl\cf3 .kr;\
	pointer = \cf4 LFSaw\cf3 .kr(rate, off, 0.5, 0.5);\
	frqs = \cf4 AtsFreq\cf3 .kr(buffer, parts, pointer) * 0.125;\
	amps = \cf4 AtsAmp\cf3 .kr(buffer, parts, pointer);\
	sig = \cf4 VarSaw\cf3 .ar(frqs, 0, 0.5, amps) * \cf4 EnvGen\cf3 .kr(env, timeScale: dur, doneAction: 2);\
	\cf4 Out\cf3 .ar(efx, \cf4 Mix\cf3 (sig) * eamp);\
	a = \cf4 Reverb\cf3 .ar(\cf4 Mix\cf3 (sig[\cf4 Array\cf3 .series(50, 0, 4)]), 0.5).distort;\
	b = \cf4 Reverb\cf3 .ar(\cf4 Mix\cf3 (sig[\cf4 Array\cf3 .series(50, 1, 4)]), 0.4).distort;\
	c = \cf4 Reverb\cf3 .ar(\cf4 Mix\cf3 (sig[\cf4 Array\cf3 .series(50, 2, 4)]), 0.6).distort;\
	d = \cf4 Reverb\cf3 .ar(\cf4 Mix\cf3 (sig[\cf4 Array\cf3 .series(50, 3, 4)]), 0.7).distort;\
	#w, x, y, z = \cf4 A2B\cf3 .ar(a, b, c, d);\
	\cf4 Out\cf3 .ar(out, \cf4 AtkRotateXYZ\cf3 .ar(w, x, y, z, xang, yang, zang))\
\}).add;\
\
\cf4 SynthDef\cf3 (\cf5 \\pat05imp\cf3 , \{\cf4 |out, efx, aamp, eamp, dur, rate, off, buffer, xang, yang, zang|\cf3 \
	\cf4 var\cf3  sig, env, frqs, amps, parts, a, b, c, d, w, x, y, z, pointer;\
	parts = (0..199);\
	env = \cf4 EnvControl\cf3 .kr;\
	pointer = \cf4 LFSaw\cf3 .kr(rate, off, 0.5, 0.5);\
	frqs = \cf4 AtsFreq\cf3 .kr(buffer, parts, pointer) * 0.125;\
	amps = \cf4 AtsAmp\cf3 .kr(buffer, parts, pointer) ** 0.5;\
	sig = \cf4 Impulse\cf3 .ar(frqs, 0, amps) * \cf4 EnvGen\cf3 .kr(env, timeScale: dur, doneAction: 2);\
	\cf4 Out\cf3 .ar(efx, \cf4 Mix\cf3 (sig) * eamp);\
	a = \cf4 Reverb\cf3 .ar(\cf4 Mix\cf3 (sig[\cf4 Array\cf3 .series(50, 0, 4)]), 0.8).distort;\
	b = \cf4 Reverb\cf3 .ar(\cf4 Mix\cf3 (sig[\cf4 Array\cf3 .series(50, 1, 4)]), 0.7).distort;\
	c = \cf4 Reverb\cf3 .ar(\cf4 Mix\cf3 (sig[\cf4 Array\cf3 .series(50, 2, 4)]), 0.6).distort;\
	d = \cf4 Reverb\cf3 .ar(\cf4 Mix\cf3 (sig[\cf4 Array\cf3 .series(50, 3, 4)]), 0.5).distort;\
	#w, x, y, z = \cf4 A2B\cf3 .ar(a, b, c, d);\
	\cf4 Out\cf3 .ar(out, \cf4 AtkRotateXYZ\cf3 .ar(w, x, y, z, xang, yang, zang))\
\}).add;\
\
\cf4 SynthDef\cf3 (\cf5 \\pat05pmo\cf3 , \{\cf4 |out, efx, aamp, eamp, dur, rate, off, buffer, ind, xang, yang, zang|\cf3 \
	\cf4 var\cf3  sig, env, src, frqs, amps, parts, a, b, c, d, w, x, y, z, pointer;\
	parts = (0..199);\
	env = \cf4 EnvControl\cf3 .kr;\
	pointer = \cf4 LFSaw\cf3 .kr(rate, off, 0.5, 0.5);\
	frqs = \cf4 AtsFreq\cf3 .kr(buffer, parts, pointer) * 0.125;\
	amps = \cf4 AtsAmp\cf3 .kr(buffer, parts, pointer);\
	sig = \cf4 PMOsc\cf3 .ar(frqs, frqs, ind, 0, amps) * \cf4 EnvGen\cf3 .kr(env, timeScale: dur, doneAction: 2);\
	\cf4 Out\cf3 .ar(efx, \cf4 Mix\cf3 (sig) * eamp);\
	a = \cf4 Reverb\cf3 .ar(\cf4 Mix\cf3 (sig[\cf4 Array\cf3 .series(50, 0, 4)]).distort, 1);\
	b = \cf4 Reverb\cf3 .ar(\cf4 Mix\cf3 (sig[\cf4 Array\cf3 .series(50, 1, 4)]).distort, 1.5);\
	c = \cf4 Reverb\cf3 .ar(\cf4 Mix\cf3 (sig[\cf4 Array\cf3 .series(50, 2, 4)]).distort, 0.5);\
	d = \cf4 Reverb\cf3 .ar(\cf4 Mix\cf3 (sig[\cf4 Array\cf3 .series(50, 3, 4)]).distort, 2);\
	#w, x, y, z = \cf4 A2B\cf3 .ar(a, b, c, d);\
	\cf4 Out\cf3 .ar(out, \cf4 AtkRotateXYZ\cf3 .ar(w, x, y, z, xang, yang, zang))\
\}).add;\
\
\cf4 SynthDef\cf3 (\cf5 \\pat05cmb\cf3 , \{\cf4 |out, in, amp, dur, del, dec, wsz, xs, xe, ys, ye, zs, ze|\cf3 \
	\cf4 var\cf3  sig, input, pch, tds, w, x, y, z;\
	pch = \cf4 ArrayControl\cf3 .kr(\cf5 \\pch\cf3 , 4, 1);\
	tds = \cf4 ArrayControl\cf3 .kr(\cf5 \\tds\cf3 , 4, 1);\
	input = \cf4 In\cf3 .ar(in) * \cf4 EnvGen\cf3 .kr(\cf4 EnvControl\cf3 .kr, levelScale: amp, timeScale: dur);\
	sig = \cf4 LeakDC\cf3 .ar(\cf4 CombC\cf3 .ar(input, del, del, dec))\
		* \cf4 EnvGen\cf3 .kr(\cf4 Env\cf3 ([0, 1, 1, 0], [0.1, 0.8, 0.1], \cf5 \\sine\cf3 ), timeScale: dur + dec, doneAction: 2);\
	sig = \cf4 Reverb\cf3 .ar(sig, 10) * 0.04 + sig;\
	#w, x, y, z = \cf4 A2B\cf3 .ar(*\cf4 Array\cf3 .fill(4, \{\cf4 |i|\cf3 \
		\cf4 PitchShift\cf3 .ar(sig, wsz, pch[i], 0.0, tds[i])\
	\}));\
	\cf4 Out\cf3 .ar(out, \cf4 AtkRotateXYZ\cf3 .ar(w, x, y, z, \
		\cf4 Line\cf3 .kr(xs, xe, dur + dec),\
		\cf4 Line\cf3 .kr(ys, ye, dur + dec),\
		\cf4 Line\cf3 .kr(zs, ze, dur + dec) \
	))\
\}).add;}